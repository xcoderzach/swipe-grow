 /**      
 * Provides A+ v1.1 compliant promises.   
 * @module microPromise
 * @name microPromise
 * @main microPromise
 */

var task = require('microTask'); // nextTick shim


    //try {root = global} catch(e){ try {root = window} catch(e){} };
    
    /**
     * Initializes and returns a promise.
     * You may provide an object to mixin the features.
     *  
     *  Example: require microPromise
     *       var uP = require('microPromise');
     *
     *  Example: get a new promise
     *       var p = uP();
     *
     *  Example: initialize with an object
     *       var e = {x:42,test:function(){ this.fulfill(this.x) } };
     *       var p = uP(e);
     *       p.test();
     *       // resolved getter contains the value 
     *       p.resolved; // => 42
     *       // status getter contains the state
     *       p.status; // => 'fulfilled'
     *
     *  Example: initialize with a function
     *       var r = function(p){ p.fulfill('hello') };
     *       p = uP(r);
     *       p.resolved; // => 'hello'
     *
     * @constructor
     * @static
     * @param {Object} o
     * @return {Object} promise
     * @api public
     */
    var STATES = ['pending','fulfilled','rejected'];

    function microPromise(func){
        var _value, _state = 0, _tuple = [];

        var promise = {
            then: then,
            done: done,
            fulfill: fulfill,
            resolve: resolve,
            reject: reject,   
        };

        Object.defineProperty(promise,'state',{
            set: function(s){_state = s; return _state;}, 
            get: function(){return _state;}
        })

        Object.defineProperty(promise,'value',{
            set: function(v){_value = v; return _value; }, 
            get: function(){return _value;}
        })

        Object.defineProperty(promise,'status',{
            get: function(){ return STATES[_state] }
        })

        Object.defineProperty(promise,'tuple',{
            get: function(){ return _tuple }
        })

        Object.defineProperty(promise,'isPending',{
            get: function(){ return _state === 0 }
        })

        if(typeof func === 'function') func(promise.resolve,promise.reject);

        return promise;
    }        
        /**
         * Attaches callback,errback,notify handlers and returns a promise 
         * 
         * Example: catch fulfillment or rejection
         *      var p = uP();
         *      p.then(function(value){
         *          console.log("received:", value);
         *      },function(error){
         *          console.log("failed with:", error);
         *      });
         *      p.fulfill('hello world!'); // => 'received: hello world!'
         *
         * Example: chainable then clauses
         *      p.then(function(v){
         *          console.log('v is:', v);
         *          if(v > 10) throw new RangeError('to large!');
         *          return v*2;
         *      }).then(function(v){ 
         *          // gets v*2 from above
         *          console.log('v is:', v)
         *      },function(e){
         *          console.log('error2:', e);
         *      });
         *      p.fulfill(142); // => v is: 142, error2: [RangeError:'to large']
         *
         * Example: undefined callbacks are ignored
         *      p.then(function(v){
         *          if(v < 0) throw v;
         *          return v;
         *      }).then(undefined,function(e){
         *          e = -e;
         *          return e;
         *      }).then(function(value){
         *          console.log('we got:', value);
         *      });
         *      p.fulfill(-5); // => we got: 5
         *      
         * @param {Function} onFulfill callback
         * @param {Function} onReject errback 
         * @param {Function} onNotify callback 
         * @return {Object} a decendant promise
         * @api public
         */
        function then(f,r,n){
            var p = microPromise();

            this.tuple.push([p,f,r,n]);

            if(this.state) resolver.call(this,true);

            return p;
        }

        /**
         * Same as `then` but terminates a promise chain and calls onerror / throws error on unhandled Errors 
         *
         * Example: capture error with done
         *      p.then(function(v){
         *          console.log('v is:', v);
         *          if(v > 10) throw new RangeError('to large!');
         *          return v*2;
         *      }).done(function(v){ 
         *          // gets v*2 from above
         *          console.log('v is:', v)
         *      });
         *      p.fulfill(142); // => v is: 142, throws [RangeError:'to large']
         * Example: use onerror handler
         *      p.onerror = function(error){ console.log("Sorry:",error) };
         *      p.then(function(v){
         *          console.log('v is:', v);
         *          if(v > 10) throw new RangeError('to large!');
         *          return v*2;
         *      }).done(function(v){ 
         *          // gets v*2 from above
         *          console.log('v is:', v)
         *      });
         *      p.fulfill(142); // => v is: 142, "Sorry: [RangeError:'to large']"
         *      
         * @param {Function} onFulfill callback
         * @param {Function} onReject errback 
         * @param {Function} onNotify callback 
         * @api public
         */
        function done(f,r,n){
            
            if(typeof r !== 'function') r = handleError;

            var p = this.then(f,r,n), promise = this;
        
            function handleError(e){
                task(function(){
                    if(typeof promise.onerror === 'function'){
                        promise.onerror(e);
                    } else {
                        throw e;
                    }
                });
            }
        }

        /**
         * Fulfills a promise with a `value` 
         * 
         *  Example: fulfillment
         *      p = uP();
         *      p.fulfill(123);
         *      p.resolved; // => 123
         *  Example: multiple fulfillment values
         *      p = uP();
         *      p.fulfill(1,2,3);
         *      p.resolved; // => [1,2,3]
         *      
         * @param {Object} value
         * @return {Object} promise
         * @api public
         */
        function fulfill(x){
            if(this.isPending){

                if(arguments.length > 1)
                x = [].slice.call(arguments);

                this.state = 1;
                this.value = x;

                resolver.call(this);
            }

            return this;    
        }

        /**
         * Rejects promise with a `reason`
         *
         *  Example:
         *      p = uP();
         *      p.reject('some error');
         *      p.status; // => 'rejected'
         *      p.resolved; // => 'some error'
         *      
         * @param {Object} reason 
         * @return {Object} promise
         * @api public
         */
        function reject(x){
            if(this.isPending){
                
                this.state = 2;
                this.value = x;

                resolver.call(this);
            }

            return this;    
        }

        /**
         * Run `task` after nextTick / event loop or fulfill promise unless task is a function.
         * 
         * Example:
         *       function t1(){ throw new Error('to late!') }
         *       p.defer(t1); 
         *       p.status; // => 'pending'
         *       // after nextTick 
         *       p.status; // => 'rejected'
         *       p.resolved; // => [ERROR: 'to late!']
         * Example:
         *       p.defer([task1,task2,task3]);
         *       // schedules task1-3 to run after nextTick
         * Example: 
         *       p.defer('hello');
         *       // ... after nextTick
         *       p.resolved; // 'hello'
         *       p.status; // 'fulfilled'
         *
         * @param {Function} task
         * @return {Object} value
         * @api public 
         */
        function defer(x){
            var self = this;
            if(typeof x === 'function') {
                task(function(){
                    try { x.call(self) } catch(err) { self.reject(err) }
                });
            } else if(Array.isArray(x)) for(var i in x) this.defer(x[i]);
            else this.resolve(x);

            return this;
        }


        /**
         * Resolves a value
         *  
         *  Example:
         *      p = uP();
         *      a = uP(); 
         *      p.resolve(a); // resolves value from promise
         *      p.status; // => 'pending'
         *      a.fulfill('hello');
         *      p.status; // => 'fulfilled'
         *      p.resolved; //=> 'hello'
         *  
         *  Example:
         *      p = uP();
         *      p.resolve('hello'); // resolve a literal
         *      p.status; // => 'fulfilled'
         *      p.resolved; // => 'hello'
         *    
         * @param {Object} reason 
         * @return {Object} promise
         * @api public
         */
        function resolve(x){
            var thenable, z = 0, p = this;

            if(x === p) reject.call(p,new TypeError("x === p"));

            if(x && (typeof x === 'object' || typeof x === 'function')){
                try { thenable = x.then } catch(e){ reject.call(p,e) }
            }

            if(typeof thenable === 'function'){
                try {
                    thenable.apply(x,[function(y){
                        if(!z++) resolve.call(p,y);
                    },function(r){
                        if(!z++) reject.call(p,r);
                    }]);
                } catch(e) {
                    if(!z++) reject.call(p,e);
                }    
            } else {
                fulfill.call(p,x);
            }

            return this;
        }

        function resolver(now){

            var state = this.state,
                value = this.value,
                tuple = this.tuple;

            now = now ? r() : task(r);

            function r(){  
                var t, p, h, x = value;

                while(t = tuple.shift()) {
                    p = t[0];
                    h = t[state];

                    if(typeof h === 'function') {
                        try {
                            x = h(value);
                            resolve.call(p,x);
                        } catch(e) {
                            reject.call(p,x);
                        }     
                    } else {
                        if(p.isPending){
                            p.state = state;
                            p.value = x;
                            resolver.call(p);
                        }
                    }
                }
            }
        }

/* expose this module */
if(module && module.exports) module.exports = microPromise;
else if(typeof define ==='function' && define.amd) define(microPromise); 
else {
    microPromise = microPromise;   
}


