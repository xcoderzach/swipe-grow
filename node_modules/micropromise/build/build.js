
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("kaerus-component-microTask/index.js", function(exports, require, module){

(function(root){
    "use strict"

    try {root = global} catch(e){}

    var defer, observer, tasks = [];
    
    if(root.process && typeof root.process.nextTick === 'function') defer = root.process.nextTick;
    else if(root.vertx && typeof root.vertx.runOnLoop === 'function') defer = root.vertx.RunOnLoop;
    else if(root.vertx && typeof root.vertx.runOnContext === 'function') defer = root.vertx.runOnContext;
    else if(observer = root.MutationObserver || root.WebKitMutationObserver) {
        defer = (function(document, observer, drain) {
            var el = document.createElement('div');
                new observer(drain).observe(el, { attributes: true });
                return function() { el.setAttribute('x', 'y'); };
        }(document, root.MutationObserver, microTask.drain));
    }
    else if(typeof root.setTimeout === 'function' && (root.ActiveXObject || !root.postMessage)) {
        defer = function(f){ root.setTimeout(f,0); }
    }
    else if(root.MessageChannel && typeof root.MessageChannel === 'function') {
        var fifo = [], channel = new root.MessageChannel();
        channel.port1.onmessage = function () { (fifo.shift())() };
        defer = function (f){ fifo[fifo.length] = f; channel.port2.postMessage(0); };
    } else throw new Error("No candidate for microTask defer()")

    function microTask(t){
        if(tasks.push(t) === 1) defer(microTask.drain);
    }

    microTask.drain = function(){ 
        for(var i = 0, l = tasks.length; i < l; i++) tasks[i]();
        tasks = []; 
    }

    microTask.insert = function(task,position){
        position = position ? position : 0;
        tasks.splice(position,0,task);
    }

    microTask.indexOf = function(task){ 
        return tasks.indexOf(task);
    } 

    microTask.has = function(task){
        return !(tasks.indexOf(task) < 0)
    }

    microTask.cancel = function(task){
        if(typeof task === 'function' && (task = tasks.indexOf(task)) < 0) return;
        else if(task == undefined) { tasks = []; return; } 

        return tasks.splice(task,1);
    }
    
    if(module && module.exports) module.exports = microTask;
    else if(typeof define ==='function' && define.amd) define(microTask); 
    else root.microTask = microTask;
}(this));

});
require.register("uP/index.js", function(exports, require, module){
 /**      
 * Provides A+ v1.1 compliant promises.   
 * @module uP
 * @name microPromise
 * @main uP
 */

var task = require('microTask'); // nextTick shim

(function(root){
    "use strict"

    try {root = global} catch(e){}
    
    /**
     * Initializes and returns a promise
     * Provide an object to mixin the features or a resolver callback function.
     *  
     *  Example: require uP
     *       var uP = require('uP');
     *
     *  Example: get a new promise
     *       var p = uP();
     *
     *  Example: initialize with object
     *       var e = {x:42,test:function(){ this.fulfill(this.x) } };
     *       var p = uP(e);
     *       p.test();
     *       // resolved getter contains the value 
     *       p.resolved; // => 42
     *       // status getter contains the state
     *       p.status; // => 'fulfilled'
     *
     *  Example: initialize with a function
     *       var r = function(r){ r.fulfill('hello') };
     *       p = a(r);
     *       p.resolved; // => 'hello'
     *
     * @constructor
     * @static
     * @param {Object} o
     * @return {Object} promise
     * @api public
     */
    function uP(proto){
        "use strict";

        proto = proto ? proto : {};

        var promise,
            states = ['pending','fulfilled','rejected'],
            state = 0, 
            value,
            timer, 
            tuple = [];

        promise = Object.create(proto,{
            then: {value: then},
            done: {value: done},
            defer:{ value: defer },
            fulfill: {value: fulfill},
            reject: {value:  reject},
            resolve: {value:  resolve},
            /**
            * returns `status` of promise which can be either 'pending', 'fulfilled' or 'rejected'
            * 
            * @attribute status 
            * @return {String} status
            * @api public 
            */
            status: {get: function(){return states[state]}},
            /**
            * returns the resolved `value`, either from fulfillment or rejection.
            * 
            * @attribute resolved
            * @return {Object} value
            * @api public 
            */
            resolved: {get: function(){return value}},
            isPending: {get: function(){return state === 0}}
        });

        if(typeof proto === 'function') proto(promise);

        
         /**
         * Attaches callback,errback,notify handlers and returns a promise 
         * 
         * Example: catch fulfillment or rejection
         *      var p = uP();
         *      p.then(function(value){
         *          console.log("received:", value);
         *      },function(error){
         *          console.log("failed with:", error);
         *      });
         *      p.fulfill('hello world!'); // => 'received: hello world!'
         *
         * Example: chainable then clauses
         *      p.then(function(v){
         *          console.log('v is:', v);
         *          if(v > 10) throw new RangeError('to large!');
         *          return v*2;
         *      }).then(function(v){ 
         *          // gets v*2 from above
         *          console.log('v is:', v)
         *      },function(e){
         *          console.log('error2:', e);
         *      });
         *      p.fulfill(142); // => v is: 142, error2: [RangeError:'to large']
         *
         * Example: undefined callbacks are ignored
         *      p.then(function(v){
         *          if(v < 0) throw v;
         *          return v;
         *      }).then(undefined,function(e){
         *          e = -e;
         *          return e;
         *      }).then(function(value){
         *          console.log('we got:', value);
         *      });
         *      p.fulfill(-5); // => we got: 5
         *      
         * @param {Function} onFulfill callback
         * @param {Function} onReject errback 
         * @param {Function} onNotify callback 
         * @return {Object} a decendant promise
         * @api public
         */
        function then(f,r,n){
            var p = uP(proto);

            tuple[tuple.length] = [p,f,r,n];

            if(state) task(resolver);

            return p;
        }

        /**
         * Same as `then` but terminates a promise chain and calls onerror / throws error on unhandled Errors 
         *
         * Example: capture error with done
         *      p.then(function(v){
         *          console.log('v is:', v);
         *          if(v > 10) throw new RangeError('to large!');
         *          return v*2;
         *      }).done(function(v){ 
         *          // gets v*2 from above
         *          console.log('v is:', v)
         *      });
         *      p.fulfill(142); // => v is: 142, throws [RangeError:'to large']
         * Example: use onerror handler
         *      p.onerror = function(error){ console.log("Sorry:",error) };
         *      p.then(function(v){
         *          console.log('v is:', v);
         *          if(v > 10) throw new RangeError('to large!');
         *          return v*2;
         *      }).done(function(v){ 
         *          // gets v*2 from above
         *          console.log('v is:', v)
         *      });
         *      p.fulfill(142); // => v is: 142, "Sorry: [RangeError:'to large']"
         *      
         * @param {Function} onFulfill callback
         * @param {Function} onReject errback 
         * @param {Function} onNotify callback 
         * @api public
         */
        function done(f,r,n){
            
            if(typeof r !== 'function') r = handleError;

            var p = this.then(f,r,n);
        
            function handleError(e){
                task(function(){
                    if(typeof promise.onerror === 'function'){
                        promise.onerror(e);
                    } else {
                        throw e;
                    }
                });
            }
        }

        /**
         * Fulfills a promise with a `value` 
         * 
         *  Example: fulfillment
         *      p = uP();
         *      p.fulfill(123);
         *      p.resolved; // => 123
         *  Example: multiple fulfillment values
         *      p = uP();
         *      p.fulfill(1,2,3);
         *      p.resolved; // => [1,2,3]
         *      
         * @param {Object} value
         * @return {Object} promise
         * @api public
         */
        function fulfill(x){
            if(!state){

                if(arguments.length > 1)
                x = [].slice.call(arguments);

                state = 1;
                value = x;

                task(resolver);
            }

            return this;    
        }

        /**
         * Rejects promise with a `reason`
         *
         *  Example:
         *      p = uP();
         *      p.reject('some error');
         *      p.status; // => 'rejected'
         *      p.resolved; // => 'some error'
         *      
         * @param {Object} reason 
         * @return {Object} promise
         * @api public
         */
        function reject(x){
            if(!state){

                state = 2;
                value = x;

                task(resolver);
            }

            return this;    
        }

        /**
        * Run `task` after nextTick / event loop or fulfill promise unless task is a function.
        * 
        * Example:
        *       function t1(){ throw new Error('to late!') }
        *       p.defer(t1); 
        *       p.status; // => 'pending'
        *       // after nextTick 
        *       p.status; // => 'rejected'
        *       p.resolved; // => [ERROR: 'to late!']
        * Example:
        *       p.defer([task1,task2,task3]);
        *       // schedules task1-3 to run after nextTick
        * Example: 
        *       p.defer('hello');
        *       // ... after nextTick
        *       p.resolved; // 'hello'
        *       p.status; // 'fulfilled'
        *
        * @param {Function} task
        * @return {Object} value
        * @api public 
        */
        function defer(t){
            if(typeof t === 'function') task(enclose(t));
            else if(Array.isArray(t)) for(var i in t) defer(t[i]);
            else fulfill(t);

            return this;
        }

        function enclose(func){
            try { func.call(promise) } catch(err) { reject(err) }
        }

        function resolver(){
            var t, p, h, x = value;

            while(t = tuple.shift()) {
                p = t[0];
                h = t[state];

                if(typeof h === 'function') {
                    try {
                        x = h(value);
                        p.resolve(x);
                    } catch(e) {
                        p.reject(e);
                    }     
                } else {
                    if(state == 1) p.fulfill(x);
                    else if(state == 2) p.reject(x);
                }
            }
        }

        function resolve(x){
            var thenable, z = 0, p = this;

            if(x === p) reject(new TypeError("x === p"));

            if(x && (typeof x === 'object' || typeof x === 'function')){
                try { thenable = x.then } catch(e){ reject(e) }
            }

            if(typeof thenable === 'function'){
                try {
                    thenable.apply(x,[function(y){
                        if(!z++) p.resolve(y);
                    },function(r){
                        if(!z++) p.reject(r);
                    }]);
                } catch(e) {
                    if(!z++) reject(e);
                }    
            } else {
                fulfill(x);
            }
        }

        return promise;
    }

    /* expose this module */
    if(module && module.exports) module.exports = uP;
    else if(typeof define ==='function' && define.amd) define(uP); 
    else root.uP = uP;
}(this));


});
require.alias("kaerus-component-microTask/index.js", "uP/deps/microTask/index.js");
require.alias("kaerus-component-microTask/index.js", "microTask/index.js");
