{
  "author": {
    "name": "Quildreen \"Sorella\" Motta",
    "email": "quildreen@gmail.com"
  },
  "name": "athena",
  "description": "Strategically gives you awesome functional combinators for an abstraction war!",
  "version": "0.2.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/killdream/athena.git"
  },
  "main": "./lib/index.js",
  "scripts": {
    "test": "make test",
    "prepublish": "make prepublish"
  },
  "dependencies": {},
  "devDependencies": {
    "LiveScript": "~1.1.1",
    "brofist-tap": "~0.1.0",
    "chai": "~1.6.0",
    "brofist": "~0.2.2",
    "brofist-minimal": "~0.1.1",
    "claire": "~0.3.4",
    "browserify": "~2.14.1",
    "chai-as-promised": "~3.3.1",
    "pinky": "~0.1.2"
  },
  "optionalDependencies": {},
  "license": "MIT",
  "readmeFilename": "README.md",
  "calliope": {
    "output": "docs/api",
    "copyright": "Â© 2013 Quildreen \"Sorella\" Motta",
    "packages": [
      {
        "files": [
          "src/*.ls"
        ]
      }
    ]
  },
  "testling": {
    "files": "build/test/tap.js",
    "browsers": [
      "ie/6..latest",
      "chrome/20..latest",
      "firefox/15..latest",
      "safari/latest",
      "opera/11.0..latest",
      "iphone/6",
      "ipad/6"
    ]
  },
  "keywords": [
    "functional",
    "fp",
    "higher-order",
    "curry",
    "partial",
    "logic",
    "lambda"
  ],
  "readme": "# Athena [![Build Status](https://travis-ci.org/killdream/athena.png)](https://travis-ci.org/killdream/athena) ![Dependencies Status](https://david-dm.org/killdream/athena.png)\n\n\nAthena is a library that provides core functional combinators like `Curry`,\n`Compose`, `Partial`, etc. Combinators range from lambda calculus, to general\nhigher-order functions, to logic and control-flow combinators.\n\n\n## Example\n\n```js\nvar _ = require('athena')\n\nfunction add2(a, b) { return a + b }\n\nvar add = _.curry(add2)\n\n_.compose( _.add(1)\n         , _.uncurry(add2)\n         , _.k([2, 3])\n         )()\n// => 6\n```\n\n\n## Installing\n\nThe easiest way is to grab it from NPM (use [browserify][] if you're on a\nBrowser):\n\n    $ npm install athena\n    \nIf you **really** want to continue suffering with old and terrible module\nsystems (or use no module system at all), you can run `make dist` yourself:\n\n    $ git clone git://github.com/killdream/athena\n    $ cd athena\n    $ npm install\n    $ make dist\n    # Then use `dist/athena.umd.js` wherever you want.\n    \n[browserify]: https://github.com/substack/node-browserify\n    \n\n## Platform support\n\nThis library assumes an ES5 environment, but can be easily supported in ES3\nplatforms by the use of shims. Just include [es5-shim][] :3\n\n[es5-shim]: https://github.com/kriskowal/es5-shim\n\n[![browser support](https://ci.testling.com/killdream/athena.png)](http://ci.testling.com/killdream/athena)\n\n\n## Tests\n\n    $ npm test\n    \n    \n## API\n\n### `noop()`\n\nDoes nothing.\n\n```hs\nnoop: () -> ()\n```\n```js\nnoop(1) // => undefined\n```\n\n\n### `k(a)`\n\nThe constant function in lambda calculus.\n\n```hs\nk: A -> () -> A\n```\n```js\nk(1)(2) // => 1\n```\n\n### `id(a)`\n\nThe identity function in lambda calculus.\n\n```hs\nid: A -> A\n```\n```js\nid(1) // => 1\n```\n\n### `delay(seconds, f)`\n\nExecutes the given function after (at least) the given seconds.\n\n```hs\ndelay: number -> (A... -> B) -> timer-id\n```\n```js\ndelay(0.5, function(){ console.log(2) })\nconsole.log(1)\n// 1\n// 2\n```\n\n### `defer(f)`\n\nExecutes the function asynchronously, as soon as possible.\n\n```hs\ndefer: (A... -> B) -> ()\n```\n```js\ndefer(function(){ console.log(2) })\nconsole.log(1)\n// 1\n// 2\n```\n\n### `compose(...)`\n\nFunction composition (`compose(f, g)(x)` = `f(g(x))`).\n\n```hs\ncompose: (A... -> B)... -> A... -> B\n```\n```js\nfunction double(x){ return x + x }\nfunction squared(x){ return x * x }\n\nvar doubleSquared = compose(squared, double)\ndoubleSquared(2) // => 16\n```\n\n### `curry(arity, f, ...)`\n\nCreates a curried function from an uncurried one.\n\n```hs\ncurry: number?, (A... -> B), [A]? -> A... -> (A... -> B) | B\n```\n```js\nfunction add(a, b){ return a + b }\nvar curriedAdd = curry(add)\n\nvar add1 = curriedAdd(1)\nadd1(2) // => 3\n```\n\n### `partial(f, ...)`\n\nPartially applies the given arguments to a function.\n\n```hs\npartial: (A... -> B), A... -> A... -> B\n```\n```js\nfunction add(a, b){ return a + b }\nvar add1 = partial(add, 1)\nadd1(2) // => 3\n```\n\n### `uncurry(f)`\n\nTransforms a curried function to a function on lists.\n\n```hs\nuncurry: (A... -> B) -> [A] -> B\n```\n```js\nvar toArray = Function.call.bind([].slice)\nfunction add(a, b){ return a + b }\nfunction sum(){ return toArray(arguments).reduce(add, 0) }\n\nsum([1, 2, 3]) // => 6\n```\n\n### `uncurryBind(f)`\n\nTransforms a curried function to a function on lists, where the first item of\nthe list is the value of `this`.\n\n```hs\nuncurryBind: (A... -> B) -> [this, A...] -> B\n```\n```js\nvar bag = {\n  items: [],\n  add: function() {\n    this.items.push.apply(this.items, arguments)\n  }\n}\n\nvar addToBag = uncurryBind(bag.add)\nvar otherBag = { __proto__: bag, items: [] }\n\naddToBag([otherBag, 1, 2])\n\notherBag.items // => [1, 2]\n```\n\n### `wrap(advice, f)`\n\nWraps the invocation of `f` in the given `advice`. The `advice` can then decide\nwhat to do with the function.\n\n```hs\nf: (A... -> B)\nwrap: (f, C... -> D) -> f -> C... -> D\n```\n```js\nfunction add(a, b) { return a + b }\nfunction trace(f, a, b) {\n  console.log('Calling %s with: %s, %s', f.name, a, b)\n  var result = f(a, b)\n  console.log('Returned: %s', result)\n  return result\n}\n\nvar tracedAdd = wrap(trace, add)\n\ntracedAdd(1, 2)\n// Calling add with: 1, 2\n// Returned: 3\n// => 3\n```\n\n### `either(predicate, consequent, alternate, ...)`\n\n`either(p, f, g)(a)` is the same as `p(a)? f(a) : g(a)`.\n\n```hs\neither: (A... -> bool) -> (A... -> B) -> (A... -> C) -> A... -> B | C\n```\n```js\nfunction isNegative(a) { return a < 0 }\nfunction negate(a) { return -a }\nvar abs = either(isNegative, negate, id)\n\nabs(-2) // => 2\nabs(2) // => 2\n```\n\n### `unless(predicate, consequent, ...)`\n\n`unless(p, f)(a)` is the same as `if (!p(a))  f(a)`.\n\nThis is also aliased as `_unless` for LiveScript/CoffeeScript.\n\n```hs\nunless: (A... -> bool) -> (A... -> B) -> A... -> maybe B\n```\n```js\nfunction isCallable(a){ return typeof a == 'function' }\nfunction raise(e){ throw new Error(e) }\nfunction unwrap(f){ return f() }\n\nunless(isCallable, unwrap)(function(){ return 1 }) // => 1\n```\n\n### `limit(n, f)`\n\nYields a function that will apply `f` the first `N` times.\n\n```hs\nlimit: number -> (A... -> B) -> (A... -> maybe B)\n```\n```js\nvar f = limit(2, id)\n[f(1), f(2), f(3)] // => [1, 2, undefined]\n```\n\n### `once(f)`\n\nYields a function that will apply `f` only once.\n\n```hs\nonce: (A... -> B) -> (A... -> maybe B)\n```\n```js\nvar f = once(id)\n[f(1), f(2)] // => [1, undefined]\n```\n\n### `until(predicate, f)`\n\nYields a function that will only apply `f` before the predicate holds.\n\nThis is also aliased as `_until` for LiveScript/CoffeeScript.\n\n```hs\nuntil: (A... -> bool) -> (A... -> B) -> (A... -> maybe B)\n```\n```js\nfunction greaterThan(a, b){ return a > b }\nfunction sub(a, b){ return a - b }\n\nvar subGreater = until(greaterThan, sub)\n\nsubGreater(1, 2) //=> undefined\nsubGreater(2, 2) //=> undefined\nsubGreater(3, 2) //=> 1\nsubGreater(0, 2) //=> -2\n```\n\n### `when(predicate, f)`\n\nYields a function that will only apply `f` after the predicate holds.\n\nThis is also aliased as `_when` for LiveScript/CoffeeScript.\n\n```hs\nwhen: (A... -> bool) -> (A... -> B) -> (A... -> maybe B)\n```\n```js\nfunction greaterThan(a, b){ return a > b }\nfunction sub(a, b){ return a - b }\n\nvar subGreater = when(greaterThan, sub)\n\nsubGreater(1, 2) //=> -1\nsubGreater(2, 2) //=> 0\nsubGreater(3, 2) //=> undefined\nsubGreater(0, 2) //=> undefined\n```\n\n### `or(...)`\n\nYields a function that will apply each function in turn, and return the value\nof the first truthy one.\n\nThis is also aliased as `_or` for LiveScript/CoffeeScript.\n\n```hs\nor: (A... -> B)... -> A... -> maybe B\n```\n\n\n### `and(...)`\n\nYields a function that will apply each function in turn, and return the value\nof the last truthy one.\n\nThis is aliased as `_and` for LiveScript/CoffeeScript.\n\n```hs\nand: (A... -> B)... -> A... -> maybe B\n```\n\n### `not(f)`\n\nYields a function that will return the negated result of applying `f`.\n\n```hs\nnot: (A... -> bool) -> A... -> bool\n```\n\n\n## Licence\n\nMIT/X11. ie.: do whatever you want.\n\n\n",
  "bugs": {
    "url": "https://github.com/killdream/athena/issues"
  },
  "_id": "athena@0.2.0",
  "_from": "athena@~0.2.0"
}
