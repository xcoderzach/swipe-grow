(function(){
  var stream, ref$, slurp, spit, chai, expect, o, x, duplex, d, text;
  stream = require('stream');
  ref$ = require('../lib'), slurp = ref$.slurp, spit = ref$.spit;
  require('mocha-as-promised')();
  chai = require('chai');
  chai.use(require('chai-as-promised'));
  expect = chai.expect;
  o = it;
  x = xit;
  duplex = function(){
    var d, data;
    d = new stream.Duplex;
    d.name = '<no>';
    data = '';
    d._write = function(buf, enc, f){
      data = buf.toString();
      d.push(data);
      return process.nextTick(function(){
        d.push(null);
        if (f) {
          return f();
        }
      });
    };
    d._read = function(n){
      if (d.hazError) {
        d.emit('error', new Error('no u'));
      }
      return data;
    };
    return d;
  };
  d = null;
  beforeEach(function(){
    d = duplex();
    return d.name = '<d>';
  });
  text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';
  describe('λ slurp', function(){
    return o('Should fulfill with the full contents of the stream.', function(){
      d.write(text);
      return expect(slurp(d)).to.become(text);
    });
  });
  describe('λ spit', function(){
    describe('with Stream', function(){
      o('Should fulfill after contents have been piped.', function(done){
        var t;
        t = duplex();
        d.write(text);
        return expect(slurp(spit(t, d))).to.become(text);
      });
      return o('Should fulfill after source is read if it\'s a standard output stream.', function(){
        d.write(text);
        return expect(spit(process.stdout, d)).to.be.fulfilled;
      });
    });
    return describe('with Strings', function(){
      return o('Should fulfill after writing to the source.', function(){
        return expect(slurp(spit(d, text))).to.become(text);
      });
    });
  });
}).call(this);
